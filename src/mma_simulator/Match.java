package mma_simulator;

public class Match {
    private static int baseMatchId = 1000;
    private final String matchId;
    private Fighter fighter1;
    private Fighter fighter2;
    private Record record;

    /**
     * Constructs a Match object with two fighters and a match ID prefix.
     * The match ID is generated by appending a unique identifier to the prefix.
     *
     * @param fighter1 the first fighter in the match
     * @param fighter2 the second fighter in the match
     * @param prefix   the prefix for the match ID
     */
    public Match(Fighter fighter1, Fighter fighter2, String prefix) {
        this.setFighter1(fighter1);
        this.setFighter2(fighter2);
        matchId = prefix + (baseMatchId++);
    }

    /**
     * Constructs a Match object with a specific match ID and two fighters.
     *
     * @param matchId   the match ID
     * @param fighter1  the first fighter in the match
     * @param fighter2  the second fighter in the match
     */
    public Match(String matchId, Fighter fighter1, Fighter fighter2) {
        this.setFighter1(fighter1);
        this.setFighter2(fighter2);
        this.matchId = matchId;
    }

    /**
     * Constructs a Match object with a match ID prefix.
     * The match ID is generated by appending a unique identifier to the prefix.
     *
     * @param prefix the prefix for the match ID
     */
    public Match(String prefix) {
        this.matchId = prefix + baseMatchId++;
    }

    /**
     * Retrieves the match ID.
     *
     * @return the match ID
     */
    public String getMatchId() {
        return matchId;
    }

    /**
     * Retrieves the first fighter in the match.
     *
     * @return the first fighter
     */
    public Fighter getFighter1() {
        return fighter1;
    }

    /**
     * Sets the first fighter in the match.
     *
     * @param fighter1 the first fighter
     * @throws IllegalArgumentException if the first fighter is not available
     */
    public void setFighter1(Fighter fighter1) {
        validateAvailability(fighter1);
        this.fighter1 = fighter1;
        fighter1.inMatch();
    }

    /**
     * Retrieves the second fighter in the match.
     *
     * @return the second fighter
     */
    public Fighter getFighter2() {
        return fighter2;
    }

    /**
     * Sets the second fighter in the match.
     *
     * @param fighter2 the second fighter
     * @throws IllegalArgumentException if the second fighter is not available
     */
    public void setFighter2(Fighter fighter2) {
        validateAvailability(fighter2);
        this.fighter2 = fighter2;
        fighter2.inMatch();
    }

    /**
     * Simulates the fight between the two fighters and updates the record.
     */
    public void fight() {
        int[] score = calculateScores();
        this.record = new Record(this, (score[0] > score[1] ? fighter1 : fighter2), score);
        fighter1.addRecord(record);
        fighter2.addRecord(record);
        fighter1.lost();
        fighter2.lost();
        record.winner().available();
    }

    /**
     * Retrieves the results of the match in a formatted string.
     *
     * @return the match results
     */
    public String getResults() {
        return String.format("%S won, score[ %d : %d] ", record.winner().getName(), record.score()[0], record.score()[1]);
    }

    /**
     * Retrieves the winner of the match.
     *
     * @return the winning fighter
     */
    public Fighter getWinner(){
        return record.winner();
    }

    // Private utility methods

    /**
     * Validates the availability of a fighter for the match.
     *
     * @param fighter the fighter to validate
     * @throws IllegalArgumentException if the fighter is not available
     */
    private void validateAvailability(Fighter fighter) {
        if (fighter.getStatus() != Fighter.Status.Available) {
            throw new IllegalArgumentException("The Fighter should be available");
        }
    }

    /**
     * Calculates the scores for each fighter based on their skills, strengths, and speeds.
     *
     * @return an array of scores for each fighter
     */
    private int[] calculateScores() {
        int[] score = new int[2];

        score[0] += compareSkills(fighter1, fighter2);
        score[1] += compareSkills(fighter2, fighter1);

        score[0] += compareStrengths(fighter1, fighter2);
        score[1] += compareStrengths(fighter2, fighter1);

        score[0] += compareSpeeds(fighter1, fighter2);
        score[1] += compareSpeeds(fighter2, fighter1);

        return score;
    }

    /**
     * Compares the skills of two fighters and determines the score.
     *
     * @param fighter1 the first fighter
     * @param fighter2 the second fighter
     * @return 1 if fighter1 has higher skill, 0 otherwise
     */
    private int compareSkills(Fighter fighter1, Fighter fighter2) {
        return fighter1.getSkill() > fighter2.getSkill() ? 1 : 0;
    }

    /**
     * Compares the strengths of two fighters and determines the score.
     *
     * @param fighter1 the first fighter
     * @param fighter2 the second fighter
     * @return 1 if fighter1 has higher strength, 0 otherwise
     */
    private int compareStrengths(Fighter fighter1, Fighter fighter2) {
        return fighter1.getStrength() > fighter2.getStrength() ? 1 : 0;
    }

    /**
     * Compares the speeds of two fighters and determines the score.
     *
     * @param fighter1 the first fighter
     * @param fighter2 the second fighter
     * @return 1 if fighter1 has higher speed, 0 otherwise
     */
    private int compareSpeeds(Fighter fighter1, Fighter fighter2) {
        return fighter1.getSpeed() > fighter2.getSpeed() ? 1 : 0;
    }

    @Override
    public String toString() {
        return "Match{" +
                "matchId='" + matchId + '\'' +
                ", fighter1=" + fighter1 +
                ", fighter2=" + fighter2 +
                ", Results=" + record.toString() +
                '}';
    }
}
